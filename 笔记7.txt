1. redux基础操作
    React生态圈中的知识：
    + redux react-redux redux中间件
    + mobx 「类的装饰器」
    + react-router-dom v5/v6
    + antd\antd mobile
    + fetch及其二次封装
    + react-saga, dva, umi(nextjs)
    + antd pro
    + ...  
    复合组件通信：
    1. 父子通信「具备相同父亲的兄弟组件」：props属性「基于ref」
    2. 祖先和后代「具备相同祖先的平行组件」：context上下文
    redux/React-redux 也是实现组件之间通信的技术「插件」
    不管任何类型的组件，都可以基于这种方法，实现组件通信
    公共状态管理方案
    后期实战开发中，父子组件一般是基于：props/ref/redux，其余组件的通信一般都是基于redux管理的

    1. 在创建的store容器中，存储两部分内容
        + 公共状态：各组件需要共享/通信的信息
        + 事件池：存放一些方法「让组件可以更新的方法」
            特点：当公共状态一但发生改变，会默认立即通知事件池中的方法执行！！！
            这些方法的执行，主要目的就是让指定的组件个更新；而组件一更新，就可以获取最新的公共状态信息进行渲染
    2. 修改公共容器中的状态，不能直接去修改
        + 基于dispatch派发，通知reducer执行
        + 在reducer中去实现状态的更新
    3. 除了redux这五步核心操作外，我们还需要一些其他的知识做配合！！
        三个组件中，都需要用到创建的store容器
        我在根组件中，导入store，把其放在上下文中，后期其他组件需求，只要是它的后代组件，则直接获取使用即可。
    
    为了在各个组件中，都可以把创建的store获取到，我们可以基于上下文的方案：
    1. 在index.jsx中，基于ThemeContext.Provider把创建的store放在上下文中
    2. 因为所有组件最后都是在index.jsx中渲染，所有组件都可以理解为index.jsx的后代组件，基于上下文方案，获取在上下文中存储的store就可以了

    总结：
    redux具体的代码编写顺序
    1. 创建STORE，规划出reducer「当中的业务处理逻辑可以后续不断完善，但是最开始reducer的这个架子需要先搭建出来」
    2. 在入口中，基于上下文对象，把store放入到上下文中；需要用到store的组件，从上下文中获取
    3. 组件中基于store，完成公共状态的获取、和任务的派发
        + 使用到公共状态的组件，必须向store的事件池中加入让组件更新的办法，只有这样，才可以确保，公共状态改变，可以让组件更新，才可以获取最新的状态进行绑定

2. redux工程化开发
    我们接下来要做的事情：
    在真正的项目中，我们一定会把状态和reducer的管理，按照模块化进行划分
    redux工程化的第一步：
        按照模块，把reducer进行单独管理，每个模块都有自己的reducer；最后，我们还要把所有的reducer进行合并，合并为一个，赋值给我们创建的store！
        合并各个模块的reducer，最后创建出一个总的reducer 
            const reducer = combineReducers({
                vote: voteReducer,
                personal: personalReducer
            });
            + reducer：是最后合并的总的reducer
            + 此时容器中的公共状态，会按照我们设置的成员名字，分模块进来管理
                state = {
                    vote:{
                        supNum: 10,
                        oppNum: 5,
                        num: 0
                    },
                    personal:{
                        num: 100,
                        info: null
                    }
                }
        派发的操作不需要改动，每一次派发后，都会去所有的reducer进行逐一匹配「用派发的行为标识，和每个模块reducer中判断的行为标识进行比较」；和谁匹配成功，就执行谁的逻辑。
    redux工程化的第二步：
        第一次dispatch派发的时候，都会去每个模块的reducer中找一遍，把所有和派发行为标识匹配的逻辑执行。
        可能存在的问题：团队协作开发的时候， 因为开发的人多，最后很可能派发的行为标识会有冲突。
        所以我们一定要保证，不管哪个模块，哪个组件，我们派发的行为标识，必须是唯一的
        --------
        基于“宏管理（统一管理）”，让所有派发的行为标识，唯一性
            + 为了保证不冲突，我们一般都是这样命名：模块名_派发的行为标识「大写」
            + 变量和存储的值是一致的
            + 所有需要派发的行为标识，都在这里定义
    redux工程化的第三步：
        把派发的行为对象，按照模块进行统一的管理
            vote版块要派发的行为对象管理 
                voteAction包含好多方法，每一个方法执行，都返回要派发的行为对象
        从目前来看，此工程化步骤，不仅没有啥好处，反而让之前的操作更麻烦了
        之前每次派发，把派发的行为对象直接写出来即可
        现在，还需要把派发的行为对象，放到store/actions的某个板块下，靠方法执行才能返回我们需要的行为对象
        此操作的意义，我们称之为 创建actionCreator，在我们接下来，处理react-redux的时候，会非常的有用。

3. react-redux
    react-redux最大的特点就是：
        让redux的操作，在react项目中更简单一些
        主要是在 组件中应用的时候 会更方便一些
        1. react-redux内部自己创建了上下文对象，并且我们可以把store放在上下文中，在组件中使用的时候，无需我们自己再获取上下文中的store，他可以帮我们获取到，我们直接玩即可。
        2. 在组件中，我们想获取公共状态信息进行绑定等，无需自己基于上下文对象获取store，也无需自己再基于getState获取公共状态。直接基于react-redux提供的connect函数处理即可。而且，也不需要我们手动把组件更新的方法，放在事件池中了，react-redux内部帮我们处理了。
            connect(mapStateToProps,mapDispatchToProps)(我们要渲染的组件)
                1. mapStateToProps：可以获取到redux中的公共状态，把需要的信息作为属性，传递组件即可
                    connect(state=>{
                        // state:存储redux容器中，所有模块的公共状态信息
                        // 返回对象中的信息，就是要作为属性，传递给组件的信息
                        return {
                            supNum:state.vote.supNum,
                            info:state.personal.info
                        };
                    })(Vote);
                2. mapDispatchToProps：把需要派发的任务，当做属性传递给组件
                    connect(
                        null,
                        dispatch=>{
                            // dispatch:store.dispatch 派发任务的方法

                            // 返回对象中的信息，会作为属性传递给组件
                            return {
                                ...
                            };
                        }
                    )(Vote);
                    bindActionCreators

4. 总结：
    redux工程化处理：
        1. 把reducer/状态按照模块进行划分和管理；把所有模块的reducer合并为一个即可。
        2. 每一次任务派发，都会把所有模块的reducer依次去执行。派发时候传递的行为对象（行为标识）是统一的。所以我们要保证：各个模块之间，派发的行为标识它是唯一的。===>派发行为标识的统一管理。
        3. 创建 actionCreator 对象，按模块管理我们需要派发的对象

    在组件中使用的时候，如果使用的是redux：
    1. 我们需要创建上下文对象，基于其Provider把创建的store放在根组件的上下文信息中；后代组件需要基于上下文对象，获取到上下文中的store
    2. 需要用到公共状态的组件
        + store.getState() 获取公共状态
        + store.subscribe(让组件更新的函数) 放在事件池中
    3. 需要派发的组件
        + store.dispatch(actionCreator)
    
    react-redux就是帮助我们简化redux在组件中的应用
    1. 提供的Provider组件，可以自己在内部创建上下文对象，把store放在根组件的上下文中
    2. 提供的connect函数，在函数内部，可以获取到上下文中的store，然后快速的把公共状态，以及需要派发的操作，基于属性传递给组件
        connect(mapStateToProps,mapDispatchToProps)(渲染的组件)

    在此阶段讲课中，我们涉及的原理和源码：
    redux:
        + createStore
        + combineReducers
        + bindActionCreators
        + ...
    redux在设计上，是存在一些不好的地方的
    + 我们基于getState获取的公共状态，是直接和redux中的公共状态，共用相同的堆地址，这样导致，是可以直接修改公共状态信息的
        优化操作：我们应该在返回的时候，对状态做深拷贝处理。「返回值和redux中的公共状态」不应该是相同的堆内存
    + 我们会把让组件更新的办法，放在事件池中，当公共状态改变，会通知事件池中的所有方法执行。此操作：放置方法的时候，没有办法设置状态的依赖，这样，后期不论哪个状态被修改，事件池中所有的方法都要执行(相关的组件都要进行更新)
        优化操作：我们在向事件池中加入方法的时候，把依赖的信息也设置了。在每一次执行reducer修改状态之前，把之前的状态存储一份到「prev」，修改后的最新状态也获取到「next」。通知事件池中方法执行的时候，拿出来的某个方法是否会执行，就可以prev和next中，此方法依赖的状态是否改变。
    --------
    真实项目中，如果都这样去优化这个操作，每一次事件池中方法执行，也会有一套计算的逻辑（多多少少消耗一点点性能）；而往往，我们配合react-router操作的时候，虽然按照原有的操作逻辑，不论啥状态改变，事件池中的方法都会触发执行。但是react-router会让很多组件释放掉，只展示当前模块组件「SPA」，这样即便组件更新的方法执行，但是因为组件都释放了，所以也不会产生太大的影响。「而且我们还可以在组件释放的时候，把对应更新的方法，从事件池中移除掉」
    + 所有reducer的合并，其实不是代码的合并，而是创建一个总的reducer出来，每一次派发，都是让总的reducer执行，而在这里，会把每个模块的reducer都完完整整执行一遍「即便中间已经发现匹配的逻辑了，也会继续把其他模块中的reducer执行」
        优化操作：在某个模块的reducer中，如果派发的行为标识有匹配了「因为行为标识是统一管理的，所以遇到匹配的，说明后面不可能再匹配了」，则停止执行后面的reducer。

5. redux中间件
    + redux-logger 每一次派发，在控制台输出派发日志，方便对redux的操作进行调试。「输出的内容：派发之前的状态、派发的行为、派发后的状态」
    + redux-thunk/redux-promise 实现异步派发「每一次派发的时候，需要传递给reducer的action对象中的内容，是需要异步获取的」
        在不使用任何中间件的情况下，actionCreator对象中，是不支持异步操作的；
        我们要保证方法执行，要必须立即返回标准的action对象。
        真实项目中，往往我们是真的需要异步操作的，例如：在派发的时候，我们需要先向服务器发送请求，把数据拿到后，在进行派发。此时我们需要依托于一些中间件来进行处理。官方推荐：redux-thunk
            redux-promise和redux-thunk中间件，都是处理异步派发的，他们相同的地方
                1. 都是派发两次
                    + 第一次派发用的是，重写后的dispatch；这个方法不回去校验对象是否有type属性；也不会在乎传递的对象是否为标准普通对象
                    + 此次派发，仅仅是为了第二次派发做准备
                        + redux-thunk：把返回的函数执行，把真正的disptach传递给函数
                        + redux-promise：监听返回的promise实例，在实例为成功后，需要基于真正的dispatch，把成功的结果，在进行派发
                        区别：
                        redux-thunk的第二次派发是手动处理的
                        redux-promise是自动处理的
    + redux-saga

6. Redux改造TASK-OA
    + redux在真实项目中的运用：
        1. 实现组件之间的信息共享或者通信
        2. 对数据进行缓存/存储
    + 开发流程
        1. react工程化操作
        2. 基于react-redux实现需求
    + 数据缓存，避免重复发请求