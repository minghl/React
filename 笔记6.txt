1. 父子组件通信
    @1 就是以父组件为主导，基于“属性”实现通信
        原因：只有父组件可以调用子组件，此时才可以基于属性，把信息传递给子组件
            + 父组件基于属性，可以把信息传递给子组件「父->子」
            + 父组件基于属性「插槽」，可以把HTML结构传递给子组件「父->子」
            + 父组件把方法基于属性传递给子组件，子组件把传递的方法执行「子->父」
    @2 就是父组件基于ref获取子组件实例「或者子组件基于useImperativeHandle暴露的数据和方法」
    ===========
    我们调用Antd就是经典的父子组件通信

    组件渲染的顺序：依赖于深度优先原则
        父组件第一次渲染：
        父willMount->父render「子willMount->子render->子didMount」->父didMount
        ---
        父组件更新：
        父shouldUpdate->父willUpdate->父render「子willReceiveProps->子shouldUpdate->子willUpdate->子render->子didUpdate」->父didUpdate
            特殊：我们完全可以在子组件内部做优化处理，验证传递的属性值有没有变化，如果没有变化，则禁止更新
        --- 
        父组件释放：
        父willUnmount->父释放中「子willUnmount->子释放」->父释放

2. 祖先后代通信
    第一步：创建一个上下文对象，用来管理上下文中的信息
    第二步：让祖先组件Vote，具备状态和修改状态的方法，同时还需要把这些信息，存储到上下文中
    第三步：在后代组件中，我们需要获取上下文中的信息
        + VoteMain：获取信息绑定即可
        + VoteFooter：获取信息，把获取的函数（修改祖先组件状态的函数），再点击支持/反对的时候执行
    上下文操作的核心是上下文对象，创建多个不同的上下文对象，可以基于不同上下文对象中的Provider存放不同的上下文信息，同时也基于不同的对象，获取指定上下文中的信息。 