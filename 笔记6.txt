1. 父子组件通信
    @1 就是以父组件为主导，基于“属性”实现通信
        原因：只有父组件可以调用子组件，此时才可以基于属性，把信息传递给子组件
            + 父组件基于属性，可以把信息传递给子组件「父->子」
            + 父组件基于属性「插槽」，可以把HTML结构传递给子组件「父->子」
            + 父组件把方法基于属性传递给子组件，子组件把传递的方法执行「子->父」
    @2 就是父组件基于ref获取子组件实例「或者子组件基于useImperativeHandle暴露的数据和方法」
    ===========
    我们调用Antd就是经典的父子组件通信

    组件渲染的顺序：依赖于深度优先原则
        父组件第一次渲染：
        父willMount->父render「子willMount->子render->子didMount」->父didMount
        ---
        父组件更新：
        父shouldUpdate->父willUpdate->父render「子willReceiveProps->子shouldUpdate->子willUpdate->子render->子didUpdate」->父didUpdate
            特殊：我们完全可以在子组件内部做优化处理，验证传递的属性值有没有变化，如果没有变化，则禁止更新
        --- 
        父组件释放：
        父willUnmount->父释放中「子willUnmount->子释放」->父释放

2. 祖先后代通信
    第一步：创建一个上下文对象，用来管理上下文中的信息
    第二步：让祖先组件Vote，具备状态和修改状态的方法，同时还需要把这些信息，存储到上下文中
    第三步：  在后代组件中，我们需要获取上下文中的信息
        + VoteMain：获取信息绑定即可
        + VoteFooter：获取信息，把获取的函数（修改祖先组件状态的函数），再点击支持/反对的时候执行
    上下文操作的核心是上下文对象，创建多个不同的上下文对象，可以基于不同上下文对象中的Provider存放不同的上下文信息，同时也基于不同的对象，获取指定上下文中的信息。 

3. React样式私有化
    在组件开发的项目中，最后我们要把所有组件合并在一起进行渲染「SPA单页面应用」
        这样就会存在一个问题：各组件之间的样式，可能会冲突。所以：如何保持各组件之间的样式不冲突「样式私有化」，则是组件化开发中，必须要考虑的事情。
    @1 每个组件的样式，不再基于样式类名处理了，而是使用内联式「原理：设置为行内样式」
        但是：
        1. 不利于样式的复用，如果提取为一个通用样式对象，则没有代码提示
        2. 不能使用伪类
        3. 编译后的样式和结构混淆在一起，也不利于优化
        ...   
        这种方式绝对不能成为项目中的主流处理方式，但是偶尔有一些需求，我们可以基于这种方式处理
        例如：
        1. 样式是基于程序动态计算出来的，我们可以基于style方式，动态设置样式
        2. 偶尔有一些标签，需要设置一个权重较高特殊样式，可以基于style的方式「原理：行内样式的优先级会高一些」
    @2 样式处理技巧，基于样式表、样式类名这样的方式，但是需要人为有意识的、有规范的规避样式冲突问题
        + 首先保证每个组件最外层样式类名是不冲突的
            命名方案：路径+组件名 作为组件外层容器的名字
        + 后期组件内部的元素，其样式，都基于less/sass/stylus嵌入到指定外层容器的样式类名之下去编写
        这种方案，在很多公司/项目中都有用
        但是：
        1. 产生冲突
        2. 性能低
        3. 没有真正的动态样式
        ...
        优点：
        1. 结构样式分离
        2. 使用css所有功能
        3. 使用缓存
        4. 易编写
    @3 CSS Modules 实现样式私有化管理
        1. 我们的样式都写在xxx.module.css文件中，这样的文件都是CSS文件，不能再使用less/sass/stylus这样的预编译语言了
        2. 我们在组件中，基于ES6Module木块规范导入进来
            import xxx from 'xxx.module.css'
            xxx存储的是一个对象：
                + 键：我们之前在css中编写的样式类名 .box{}
                + 值：经过webpack编译后的样式类名 .Nav_box_c6EW3{}
        3. 我们编写的CSS样式也会被编译，所以之前的样式，也都编译为混淆后的雷鸣了「和上述对象中编译后的值一样」
        4. 我们在组件中，所有元素的样式类，基于sty.xxx去操作
        + xxx.module.css
        + import xxx from 'xxx.module.css'
        + <h2 className={`${style.title} ${commen.hoverColor}`}></h2>
        + :global(.clearfix){
            clear:both
        }
        CSS Modules的原理：
        把各个组件中，编写的样式「不经过处理之前，是全局都生效样式」进行私有化处理
            + 把所有样式类名，进行混淆编译，保证唯一性   
    @4 JSS 基于createUseStyles方法，构建组件需要的样式；返回结果是一个自定义Hook函数
        + 对象中的每个成员就是创建的样式类名
        + 可以类似于less等预编译语言中的“嵌套语法”，给其后代/伪类等设置样式
        自定义Hook执行，返回一个对象，对象中包含：
            + 我们创建的样式类名，作为属性名
            + 编译后的样式类名「唯一的」，作为属性值
            const useStyles = createUseStyles({
                box:{
                    backgroundColor:'lightblue',
                    width:'300px'
                },
            })
            {box:'box-0-2-1',title:'title-0-2-2',list:'list-0-2-3'}
        而我们在JS中编写的样式，最后会编译为：
            .box-0-2-1  {
                width:300px;
                background-color:lightblue;
            }
            .title-0-2-2 {
                color:red;
                font-size:20px;
            }
            .title-0-2-2:hover{
                color:green;
            }
            .list-0-2-3 a{
                color:#000;
                font-size:16px;
            }
        相较于CSSModules的好处：因为样式是卸载JS中的，我们就可以基于一些逻辑操作，实现样式的动态化管理 
        在类组件中，不能直接使用ReactJSS，需要经过处理 
            创建一个代理组件（函数组件）：获取基于ReactJSS编写的样式，把获取的样式基于属性传递给类组件
            方法执行要返回一个函数组件：我们基于export default导出的是这个组件，在App调用的也是这个组件（HOC）
        思想：CSS-IN—JS
            在JS中写CSS
            可以基于逻辑动态管理CSS
    @5 基于 “styled.标签名” 这种方式编写需要的样式
        + 样式要写在“ES6模版字符串”中
        + 返回并且导出的结果是一个自定义组件
        如果编写样式的时候没有提示，我们可以在vscode中安装一个官方插件：vscode-styled-components
        编写组件的样式：基于CSS-IN-JS思想中的styled-components插件
    总结：
        1. 行内样式 style={{...}}
            + 不适用于 普通样式/主流样式的编写
            + 特殊的需求可以基于其处理：样式需要基于逻辑动态计算、想基于行内样式提高样式权重
        2. 人为有意识、有规范的保证组件最外层样式类名的唯一性，组件内部的元素，都嵌入到这个样式样式类中进行编写
            + 依赖于人「不能100%保证样式类的唯一性」
            + 可能还会有部分样式，因为选择器权重问题，发生一些冲突

        --------原理：基于技术方法，让组件和元素的样式类名唯一
        3. CSS Modules 本质还是写样式表「所以编写的样式都是静态的」
            + 用起来不是那么的方便「不能再使用嵌套等操作了」
        4. CSS-IN-JS思想：把CSS写在JS中，这样可以基于JS洛基实现 样式的动态管理、实现通用样式的封装
            + React-JSS
            + styled-components「更简单」

4. 高阶组件
    React高阶组件：利用JS中的闭包「柯理化函数」实现组件代理
        我们可以在代理组件中，经过业务逻辑的处理，获取一些信息，最后基于属性等方案，传递给我们最重要渲染的组件
        执行ProxyTest方法，传递一个组件进来「Component」
        把函数执行的返回结果「应该是一个组件」，基于ES6Module规范导出，供App导入使用 。HOC(higher-order-components)
    